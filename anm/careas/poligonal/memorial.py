from ast import Raise
import copy, re
from dataclasses import dataclass, field
import numpy as np

from .shapes import (
    savePointsWGS84, 
    savePolygonWGS84
    )

from .util import (
    forceverdPoligonal,
    readMemorial, 
    formatMemorial,    
    parse_coordinates,
    )

from .geographic import (
    wgs84PolygonAttributes,
    wgs84Inverse, 
    wgs84Direct,
    wgs84InverseAngle
    )


round_angle_verd = lambda x: round(x/90)*90 # round number to 90's rumos verdadeiros

## TODO create a class to store poligonal information like SCM page poligonal
# fields

@dataclass
class PA():
    """Ponto de Amarracao"""
    description : str = field(init=False, default='')
    lat : float 
    lon : float 
    vec_angle : float
    vec_len : float     


@dataclass
class Poligon():
    DATUM : str = field( default='')
    pa : PA = field(default=None)
    data : np.array = field(init=False, default_factory=lambda: np.array([]))
    memo : list = field(init=False, default_factory=list)
    attrs : dict = field(init=False, default_factory=dict)

    def attributes(self):
        """calculate num vertices, perimeters (meters) and area (hectares) if `self.data`"""
        if self.data.size:
            n, perimeter, area = wgs84PolygonAttributes(self.data.tolist())
            self.attrs.update({'n': n, 'perimeter': perimeter, 'area': area})
        return self.attrs

    # TODO implement same approach bellow two pathways
    # but no reason since round angles/distances already deals with inprecision
    def memo_from_points(self, points, round_verd=True, round_dist=2, 
        parse=False, fmt='scm'):
        """
        Gera 'memorial descritivo simples' a partir de coordenadas lat, lon

        * points: numpy.array or multine str
            [[lat0, lon0],[lat1, lon1]...]
            shape is [:, 2]

        * parse: False
            if True treat points as str and parse it with `util.readMemorial`
            argument `fmt` is used in this case

        * round_verd: True (default)
            round angles to 0, 90, 180, 270 etc.. 'rumos verdadeiros'

        * round_dist: int (default 2)
            number of decimal places to round distance to

        output : list
            lat, lon (primeiro vertice)
            dist1 angle1
            dist2 angle2
            ...

        Note: Uses Elipsoid WGS84 (SIRGAS 2000 equivalent)
        """  
        if parse:
            points = readMemorial(points, decimal=True, fmt=fmt)
        points = np.copy(points) # it will be set to data, must not hold references
        if (not np.alltrue(points[0] == points[-1])): # must be a closed => poligon!
            points = np.append(points, points[0:1], axis=0) # add first point to the end  
        self.data = points
        dist_angle = [] # dist, angle pairs
        prev_point = points[0].tolist() # from numpy array
        dist_angle.append(prev_point)
        for point in points[1:]:
            dist = wgs84Inverse(prev_point[0], prev_point[1], point[0],point[1])
            angle, _ = wgs84InverseAngle(prev_point[0], prev_point[1], point[0],point[1])
            prev_point = point
            if round_verd:
                angle = round_angle_verd(angle)            
            dist = round(dist, round_dist)
            dist_angle.append([dist, angle])
        self.memo = dist_angle
        return self.memo.copy()

    def points_from_memo(self, repeat_end=True):
        """
        Gera cooordenadas lat,lon a partir de memorial descritivo simples formato `memo_from_points`

        *smemo: list (generated by `memo_from_points`)
            e.g.:
            lat, lon (primeiro ponto)
            dist1 angle1
            dist2 angle2
            ...

        output :
            numpy.array 
            [[lat0, lon0],[lat1, lon1]...]
            shape is [:, 2]


        If comming from a very old process 
        MUST set PA hence -> self.pa != None
        first point is PA not a vertex  
        and so it will not be included on `self.data`  

        Note: Uses Elipsoid WGS84 (SIRGAS 2000 equivalent)

        """
        def direct(prevpoint, directions, revert=1):
            """revert=-1 go backwards"""
            points = []
            for dist, angle in directions:
                prevpoint = wgs84Direct(*prevpoint, angle, dist*revert)
                points.append(prevpoint)
            return np.array(points)
        if self.pa: # comming from very old memorial - hence PA used           
            startpoint = wgs84Direct(self.pa.lat, self.pa.lon, self.pa.vec_angle, self.pa.vec_len)
            directions = self.memo[2:] # PA and PA vec drop
        else:
            startpoint = self.memo[0] # start
            directions = self.memo[1:] # drop start vertex
        # going both sides - accuracy increases A LOT!
        half = int(len(directions))//2
        ohalf = len(directions) - half
        points_fw = direct(startpoint, directions[:half]) # forward
        points_bk = direct(startpoint, directions[::-1][:ohalf], -1) # backwards
        # mid point is the average of foward and backward pathways more precision
        midpoint = (points_bk[-1]+points_fw[-1])/2.
        points = np.concatenate(([startpoint], points_fw[:-1], [midpoint], points_bk[:-1][::-1]))
        points = np.concatenate((points,[points[0]])) # must be a poligon, hence closed!
        self.data = np.copy(points)
        if not repeat_end:
            points = points[:-1]        
        return points

    def clean_memo(self):
        """remove from memo directions where distance is 0"""
        memo = [self.memo[0]] 
        for dist, angle in self.memo[1:]:
            if dist != 0:
                memo.append([dist, angle])
        self.memo = memo 
        self.attributes()

    def memo_newstart(self, index, start_coordinates, inplace=False):
        """break walk way 'path memo' `self.memo` at index-1
        and set new start coordinate point from there"""
        memo = copy.deepcopy(self.memo)
        memo = memo[1:] # discard original start
        # split at index since it's a walk way circular
        memo = memo[index-1:] + memo[:index-1]
        # add new start point
        memo = [start_coordinates] + memo
        if inplace:            
            self.memo = memo
            self.points_from_memo()
            self.attributes()
        return memo

    def memo_from_old_str(self, old_str):
        """create `self.memo` 'memorial descritivo' from string for old processes
        using PA 'ponto de amarração', distance angles ('quadrante' n 'rumo'). 

        * old_str: str
            multline string like example bellow

        ```
        -20 14 14 3  # latitude do Ponto de Amarração  
        -43 52 50 2  # longitude do Ponto de Amarração  

        1000 SW 75 15  # distancia (metros) direção grau-minutos para o primeiro vértice  
        2200 E         # incremento direcional a partir do primeiro vértice  
        1350 S  
        2200 W  
        1350 N  
        ```
        
        Referência: Requerimento de Pesquisa Mineral Formulários 4 e 5 (old processes)    
        """
        memo = []
        def to_azimuth(quad, ang):
            """converte 'SE, 17.05' em azimute com relação ao norte clock-wise 
            geographiclib convention - range [+180,-180]
            """ # python switch : a dictionary      
            az = { 'N': 0, 'S': 180, 'W': -90, 'E': 90,  # rumos verdadeiros    
                        'SW': -180.+ang, 'SE': 180.-ang , 'NE': ang, 'NW': -ang # rumos diversos 
                    }
            return az[quad]
        
        lines = old_str.split('\n')
        # two first lines are lat and lon pa 
        array = parse_coordinates(' '.join([ s for s in lines[:2]]), decimal=True)
        
        memo.append([array[0,0], array[0,1]]) # PA 

        for line in lines[2:]:
            if line.strip(): # avoiding empty lines
                result = re.findall('(\d+\.*\d*)\W*([NSEW]+)\W*(\d{1,2})\D+(\d{1,2})*', line) # rumos diversos
                if not result: # rumos verdadeiros
                    # an azimuth is defined as a horizontal angle measured clockwise
                    # from a north base line or meridian
                    result = re.findall('(\d+\.*\d*)\W*([NSEW]+)', line)
                if not result:
                    raise Exception("Cant parse line for dist/azimuth! line bellow \n {:}".format(line))
                result = result[0] # list of 1 item
                dist, quad = float(result[0]), result[1] # distance and quadrant
                angle = 0.0 # angle may or may not be present
                if len(result) > 2:
                    angle = float(result[2])
                    if len(result) == 4:
                        angle += float(result[3])/60.
                memo.append([dist, to_azimuth(quad, angle)])

        # fill self 
        self.pa = PA(array[0,0], array[0,1], memo[1][1], memo[1][0])
        self.memo = memo.copy() # copy shallow works
        return memo

    def forceverd(self, **kwargs):
        """Aproxima coordenadas para rumos verdadeiros.  
        Aproximate decimal coordinates (lat,lon) to previous (lat or lon).
        calls `util.forceverdPoligonal`
        any optional keyword argumento can be passed"""  
        new_vertices = forceverdPoligonal(self.data, **kwargs)
        self.data = new_vertices
        return new_vertices 

    def toShapePolygon(self, filename):
        """create ESRI Polygon Shapefile from data vertices"""
        savePolygonWGS84(self.data, filename)

    def toShapePoints(self, filename):
        """create ESRI Points Shapefile from data vertices"""
        savePointsWGS84(self.data, filename)

    def copy(self):
        """return self copy"""
        return copy.deepcopy(self)

    @staticmethod
    def from_points(points, **kwargs):
        """create new `PoligonSCM` by calling `.memo_from_points`
        any optional keyword argumento can be passed
        """
        poli = Poligon()
        poli.memo_from_points(points, **kwargs)
        poli.attributes()
        return poli

    @staticmethod
    def from_memo(memo):
        """create new `PoligonSCM` by calling `.points_from_memo`
        """
        poli = Poligon()
        poli.memo = memo
        poli.points_from_memo()
        poli.attributes()
        return poli

    @staticmethod
    def from_old_memo(str_old_memo):
        """create new `PoligonSCM` by calling `.memo_from_old_str` and then `points_from_memo`
        to generate vertices
        """
        poli = Poligon()
        poli.memo_from_old_str(str_old_memo)
        poli.points_from_memo()
        poli.attributes()
        return poli     




### Calcula informatino of displacement between
def translate_info(coords, ref_coords, displace_dist=1.5):
    """
    Get translate information using closest vertices from a reference polygon
    based on displace_dist

    coords: list
        coordinates to be translated
        [[lat0, lon0],[lat1, lon1]...]

    ref_coords: str or list
         memorial descritvo de referencia
         para translate das coordenadas
         ou
         list de coordenadas para translate

    displace_dist: default 1.5 (meters)
        displace distance
        maximum distance for translate coordinates (meters)
        only first 1 point will be used as reference

    returns: tuple
        - coordinates of vertex to be used as new start reference
        - index at coords path to be replaced by this
    """
    ref_points = ref_coords.copy()
    points = coords.copy()
    if isinstance(ref_points, str):
        ref_points = readMemorial(ref_points, decimal=True, verbose=True)
    elif( (isinstance(ref_points, list) or isinstance(ref_points, np.ndarray)) and
        (isinstance(points, list) or isinstance(points, np.ndarray)) ):
        pass
    else:
        print("Invalid input formats")
        return
    refs = []
    k=0
    for j, ref_point in enumerate(ref_points):
        for i, point in enumerate(points):
            distance = wgs84Inverse(*ref_point, *point)
            #print(distance)
            if(distance < displace_dist):
                angle, _ = wgs84InverseAngle(*ref_point, *point)
                print("{:>3d} | d is {:>+5.3f} (m) | az. is {:>+4.3f} (degs) |" " from ref {:>3d} : Lat {:>4.9f} Lon {:>4.9f} to "
                "vertex {:>3d} : Lat {:>4.9f} Lon {:>4.9f} ".format(k+1, distance, angle,
                     j+1, *ref_point, i+1, *point))
                k += 1 # another vertex possible to be used as reference for translation
                refs.append([ref_point, i+1])
    print("Choose which to use as a reference vertex")
    index = -1
    index = int(input())-1    
    print("Choosen vertex ", index+1)
    return refs[index][0], refs[index][1]

def memorial_acostar(memoref, memo, reference_dist=50, round_verd=False, round_dist=2, 
        verd=True, verd_tol=0.5, save_file=True, proc_name=None, save_shape=True):
    """
    Acosta `memo` à algum ponto escolhido do `memoref`

    memorial_ref : str/list/np.ndarray
        memorial reference (static - snapping to )
    memorial: str/list/np.ndarray
        memorial with points to move 

    Where get it:
        aba poligonal or
        shape scm-sigareas
    """
    def fmt_memo(memo):
        if isinstance(memoref, str):
            return readMemorial(memoref, decimal=True, verbose=False)
        if isinstance(memo, list):
            return np.array(memo)
        if isinstance(memo, np.ndarray):
            return memo
        else:
            raise Exception('Memorial must be (string) or (list) or (ndarray)')
    ref_points = fmt_memo(memoref) 
    points = fmt_memo(memo) 
    ref_point, rep_index = translate_info(points, ref_points, displace_dist=reference_dist)     
    #poligon = Poligon.from_points(points, round_verd=round_verd, round_dist=round_dist)
    newpoligon = Poligon.from_points(points, round_verd=round_verd, round_dist=round_dist)
    newpoligon.memo_newstart(rep_index, ref_point, inplace=True)
    new_points = newpoligon.data # already generated new points
    if verd:
        print(u"Ajustando para rumos verdadeiros, tolerância :", verd_tol, " metro")
        # make 'rumos verdadeiros' acceptable by sigareas
        new_points = forceverdPoligonal(new_points, tolerancem=verd_tol)           
    proc_name = proc_name.upper() + 'MEMO.txt' if proc_name else 'MEMO.txt'
    if save_file:
        formatMemorial(new_points, save=save_file, filename=proc_name)
        print("Ready for SIGAREAS -> Corrigir Poligonal")
    if save_shape:
        newpoligon.toShapePolygon(proc_name)
    return newpoligon