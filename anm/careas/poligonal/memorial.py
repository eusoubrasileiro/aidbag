import copy
from dataclasses import dataclass, field
import numpy as np

from .util import (
    forceverdPoligonal,
    readMemorial, 
    formatMemorial,    
    )

from .geographic import (
    wgs84PolygonAtributes,
    wgs84Inverse, 
    wgs84Direct,
    wgs84InverseAngle
    )

## TODO create a class to store poligonal information like SCM page poligonal
# fields

@dataclass
class PA():
    """Ponto de Amarracao"""
    description : str = field(init=False, default='')
    lat : float 
    lon : float 
    vec_angle : float
    vec_len : float     


@dataclass
class PoligonSCM():
    area : float = field(init=False)
    DATUM : str = field(init=False)
    pa : PA = field(init=False)
    data : np.array = field(init=False, default_factory=lambda: np.array([]))
    memo : list = field(init=False, default_factory=list)

    def __post_init__(self):
        """just to make a 'default dummy constructor'"""
        self.area = -1
        self.DATUM = ''
        self.pa = PA(-1, -1, -1, -1)

    # TODO implement same approach bellow two pathways
    # but no reason since round angles/distances already deals with inprecision
    def memo_from_points(self, points, round_angle=True, round_dist=True):
        """
        Gera 'memorial descritivo simples' a partir de coordenadas lat, lon

        * points: numpy.array 
            [[lat0, lon0],[lat1, lon1]...]
            shape is [:, 2]

        output : list
            lat, lon (primeiro vertice)
            dist1 angle1
            dist2 angle2
            ...

        Note: Uses Elipsoid WGS84 (SIRGAS 2000 equivalent)
        """
        if (not np.alltrue(points[0] == points[-1])): # must be a closed poligon!
            points = np.append(points, points[0:1], axis=0) # add first point to the end       
        dist_angle = [] # dist, angle pairs
        prev_point = points[0].tolist() # from numpy array
        dist_angle.append(prev_point)
        for point in points[1:]:
            dist = wgs84Inverse(prev_point[0], prev_point[1], point[0],point[1])
            angle, _ = wgs84InverseAngle(prev_point[0], prev_point[1], point[0],point[1])
            prev_point = point
            if round_angle:
                angle = round(angle)
            if round_dist:
                dist = round(dist)
            dist_angle.append([dist, angle])
        self.memo = dist_angle
        return self.memo.copy()

    def points_from_memo(self, repeat_end=True):
        """
        Gera cooordenadas lat,lon a partir de memorial descritivo simples formato `memo_from_points`

        *smemo: list (generated by `memo_from_points`)
            e.g.:
            lat, lon (primeiro ponto)
            dist1 angle1
            dist2 angle2
            ...
        
        output :
            numpy.array 
            [[lat0, lon0],[lat1, lon1]...]
            shape is [:, 2]

        Note: Uses Elipsoid WGS84 (SIRGAS 2000 equivalent)

        """
        def direct(prevpoint, directions, revert=1):
            """revert=-1 go backwards"""
            points = []
            for dist, angle in directions:
                prevpoint = wgs84Direct(*prevpoint, angle, dist*revert)
                points.append(prevpoint)
            return np.array(points)
        startpoint = self.memo[0] # start
        directions = self.memo[1:]
        # goind both sides - accuracy increases A LOT!
        half = int(len(directions))//2
        ohalf = len(directions) - half
        points_fw = direct(startpoint, directions[:half]) # forward
        points_bk = direct(startpoint, directions[::-1][:ohalf], -1) # backwards
        # mid point is the average of foward and backward pathways more precision
        midpoint = (points_bk[-1]+points_fw[-1])/2.
        points = np.concatenate(([startpoint], points_fw[:-1], [midpoint], points_bk[:-1][::-1]))
        self.data = np.copy(points)
        if repeat_end:
            points = np.concatenate((points,[points[0]]))
        return points

    def memo_newstart(self, index, start_point, inplace=False):
        """break walk way 'path memo' `self.memo` at index-1
        and set new start coordinate point from there"""
        if not inplace:            
            memo = self.memo.copy()
        else:
            memo = self.memo
        memo = memo[1:] # discard original start
        # split at index since it's a walk way circular
        memo = memo[index-1:] + memo[:index-1]
        # add new start point
        memo = [start_point] + memo
        return memo

    def copy(self):
        """return self copy"""
        return copy.deepcopy(self)

### Calcula informatino of displacement between
def translate_info(coords, ref_coords, displace_dist=1.5):
    """
    Get translate information using closest vertices from a reference polygon
    based on displace_dist

    coords: list
        coordinates to be translated
        [[lat0, lon0],[lat1, lon1]...]

    ref_coords: str or list
         memorial descritvo de referencia
         para translate das coordenadas
         ou
         list de coordenadas para translate

    displace_dist: default 1.5 (meters)
        displace distance
        maximum distance for translate coordinates (meters)
        only first 1 point will be used as reference

    returns: tuple
        - coordinates of vertex to be used as new start reference
        - index at coords path to be replaced by this
    """
    ref_points = ref_coords.copy()
    points = coords.copy()
    if isinstance(ref_points, str):
        ref_points = readMemorial(ref_points, decimal=True, verbose=True)
    elif( (isinstance(ref_points, list) or isinstance(ref_points, np.ndarray)) and
        (isinstance(points, list) or isinstance(points, np.ndarray)) ):
        pass
    else:
        print("Invalid input formats")
        return
    refs = []
    k=0
    for j, ref_point in enumerate(ref_points):
        for i, point in enumerate(points):
            distance = wgs84Inverse(*ref_point, *point)
            #print(distance)
            if(distance < displace_dist):
                angle, _ = wgs84InverseAngle(*ref_point, *point)
                print("{:>3d} - distance is {:>+5.3f} m az. angle (degs) is {:>+4.3f} " "from ref-vertex {:>3d} : Lat {:>4.9f} Lon {:>4.9f} to "
                "vertex {:>3d} : Lat {:>4.9f} Lon {:>4.9f} ".format(k+1, distance, angle,
                     j+1, *ref_point, i+1, *point))
                k += 1 # another vertex possible to be used as reference for translation
                refs.append([ref_point, i+1])
    print("Choose which to use as a reference vertex")
    index = -1
    index = int(input())-1
    return refs[index][0], refs[index][1]




# draft version
# TODO make it better with new uses
def memorial_acostar(memorial, memorial_ref, reference_dist=50, mtolerance=0.5):
    """
    Acosta `memorial` à algum ponto escolhido da `memorial_ref`

    memorial_ref : str
        deve ser copiado da aba-poligonal

    memorial: str/list/np.ndarray

    """
    if isinstance(memorial_ref, str):
        ref_points = readMemorial(memorial_ref, decimal=True, verbose=False)
    else:
        print('memorial_ref : deve ser copiado da aba-poligonal (string)')
        return
    if isinstance(memorial, list):
        points = np.array(memorial)
    elif isinstance(memorial, str):
        points = np.array(readMemorial(memorial, decimal=True, verbose=False))
    elif isinstance(memorial, np.ndarray):
        points = memorial
    else:
        print("memorial : unknown format")

    ref_point, rep_index = translate_info(points, ref_points, displace_dist=reference_dist)
    poligon = PoligonSCM()
    memo = poligon.memo_from_points(points)
    print("simple inverse memorial")
    for line in memo:
        print(line)
    newpoligon = poligon.copy()
    newpoligon.memo_newstart(memo, rep_index, ref_point, inplace=True)
    memo_restarted_points = newpoligon.points_from_memo(repeat_end=True)
    print(u"Ajustando para rumos verdadeiros, tolerância :", mtolerance, " metro")
    # make 'rumos verdadeiros' acceptable by sigareas
    smemo_restarted_points_verd = forceverdPoligonal(memo_restarted_points, tolerancem=mtolerance)
    print("Area is ", wgs84PolygonAtributes(smemo_restarted_points_verd.tolist())[-1], " ha")
    formatMemorial(smemo_restarted_points_verd)
    print("Pronto para carregar no SIGAREAS -> corrigir poligonal")
    return smemo_restarted_points_verd